Shader "PBR Master"
{
    Properties
    {
        Color_BF3303A0("ColorBase", Color) = (0.2843983,0.6287762,0.7830189,0)
Vector1_E567A086("Reflectivity", Float) = 0.7
Vector1_F2B54871("Transparency", Float) = 0.9
Vector1_221A0FD9("RippleScale", Float) = 0.22
Vector1_3E734ED8("RippleSpeed", Float) = 1
Vector1_30FC0A4B("RippleDensity", Float) = 5
Vector1_8FDC4159("RippleThickness", Float) = 5
[HDR]Color_5856042A("RippleColor", Color) = (0.4156863,1.717647,1.286275,0)
Vector1_33B63372("WaveSpeed", Float) = 0.2
Vector1_252B0398("WaveScale", Float) = 2
Vector1_1B7394EE("FoamOffset", Float) = 0.5
Vector1_C3288503("FoamStrength", Float) = 0.2
Vector1_4A68B0E6("FoamScale", Float) = 0.2
Vector1_917CCD13("FoamSpeed", Float) = 3

    }
    SubShader
    {
        Tags
        {
            "RenderPipeline"="LightweightPipeline"
            "RenderType"="Transparent"
            "Queue"="Transparent+0"
        }
        Pass
        {
        	Tags{"LightMode" = "LightweightForward"}

        	// Material options generated by graph

            Blend SrcAlpha OneMinusSrcAlpha

            Cull Back

            ZTest LEqual

            ZWrite On

        	HLSLPROGRAM
            // Required to compile gles 2.0 with standard srp library
            #pragma prefer_hlslcc gles
            #pragma exclude_renderers d3d11_9x
            #pragma target 2.0

        	// -------------------------------------
            // Lightweight Pipeline keywords
            #pragma multi_compile _ _MAIN_LIGHT_SHADOWS
            #pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE
            #pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS
            #pragma multi_compile _ _ADDITIONAL_LIGHT_SHADOWS
            #pragma multi_compile _ _SHADOWS_SOFT
            #pragma multi_compile _ _MIXED_LIGHTING_SUBTRACTIVE
            
        	// -------------------------------------
            // Unity defined keywords
            #pragma multi_compile _ DIRLIGHTMAP_COMBINED
            #pragma multi_compile _ LIGHTMAP_ON
            #pragma multi_compile_fog

            //--------------------------------------
            // GPU Instancing
            #pragma multi_compile_instancing

            #pragma vertex vert
        	#pragma fragment frag

        	// Defines generated by graph
            #define REQUIRE_DEPTH_TEXTURE

        	#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
        	#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl"
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/UnityInstancing.hlsl"
        	#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"

            CBUFFER_START(UnityPerMaterial)
            float4 Color_BF3303A0;
            float Vector1_E567A086;
            float Vector1_F2B54871;
            float Vector1_221A0FD9;
            float Vector1_3E734ED8;
            float Vector1_30FC0A4B;
            float Vector1_8FDC4159;
            float4 Color_5856042A;
            float Vector1_33B63372;
            float Vector1_252B0398;
            float Vector1_1B7394EE;
            float Vector1_C3288503;
            float Vector1_4A68B0E6;
            float Vector1_917CCD13;
            CBUFFER_END


            struct VertexDescriptionInputs
            {
                float3 WorldSpaceNormal;
                float3 ObjectSpacePosition;
                float3 WorldSpacePosition;
            };

            struct SurfaceDescriptionInputs
            {
                float3 WorldSpaceNormal;
                float3 TangentSpaceNormal;
                float3 WorldSpaceViewDirection;
                float3 WorldSpacePosition;
                float4 ScreenPosition;
            };


            void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
            {
                RGBA = float4(R, G, B, A);
                RGB = float3(R, G, B);
                RG = float2(R, G);
            }

            void Unity_Multiply_float (float2 A, float2 B, out float2 Out)
            {
                Out = A * B;
            }

            void Unity_Multiply_float (float A, float B, out float Out)
            {
                Out = A * B;
            }

            void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
            {
                Out = UV * Tiling + Offset;
            }


        float2 unity_gradientNoise_dir(float2 p)
        {
            // Permutation and hashing used in webgl-nosie goo.gl/pX7HtC
            p = p % 289;
            float x = (34 * p.x + 1) * p.x % 289 + p.y;
            x = (34 * x + 1) * x % 289;
            x = frac(x / 41) * 2 - 1;
            return normalize(float2(x - floor(x + 0.5), abs(x) - 0.5));
        }


        float unity_gradientNoise(float2 p)
        {
            float2 ip = floor(p);
            float2 fp = frac(p);
            float d00 = dot(unity_gradientNoise_dir(ip), fp);
            float d01 = dot(unity_gradientNoise_dir(ip + float2(0, 1)), fp - float2(0, 1));
            float d10 = dot(unity_gradientNoise_dir(ip + float2(1, 0)), fp - float2(1, 0));
            float d11 = dot(unity_gradientNoise_dir(ip + float2(1, 1)), fp - float2(1, 1));
            fp = fp * fp * fp * (fp * (fp * 6 - 15) + 10);
            return lerp(lerp(d00, d01, fp.y), lerp(d10, d11, fp.y), fp.x);
        }

            void Unity_GradientNoise_float(float2 UV, float Scale, out float Out)
            { Out = unity_gradientNoise(UV * Scale) + 0.5; }

            void Unity_Multiply_float (float3 A, float3 B, out float3 Out)
            {
                Out = A * B;
            }

            void Unity_Add_float3(float3 A, float3 B, out float3 Out)
            {
                Out = A + B;
            }


        inline float2 unity_voronoi_noise_randomVector (float2 UV, float offset)
        {
            float2x2 m = float2x2(15.27, 47.63, 99.41, 89.98);
            UV = frac(sin(mul(UV, m)) * 46839.32);
            return float2(sin(UV.y*+offset)*0.5+0.5, cos(UV.x*offset)*0.5+0.5);
        }

            void Unity_Voronoi_float(float2 UV, float AngleOffset, float CellDensity, out float Out, out float Cells)
            {
                float2 g = floor(UV * CellDensity);
                float2 f = frac(UV * CellDensity);
                float t = 8.0;
                float3 res = float3(8.0, 0.0, 0.0);

                for(int y=-1; y<=1; y++)
                {
                    for(int x=-1; x<=1; x++)
                    {
                        float2 lattice = float2(x,y);
                        float2 offset = unity_voronoi_noise_randomVector(lattice + g, AngleOffset);
                        float d = distance(lattice + offset, f);

                        if(d < res.x)
                        {

                            res = float3(d, offset.x, offset.y);
                            Out = res.x;
                            Cells = res.y;

                        }
                    }

                }

            }

            void Unity_Power_float(float A, float B, out float Out)
            {
                Out = pow(A, B);
            }

            void Unity_Multiply_float (float4 A, float4 B, out float4 Out)
            {
                Out = A * B;
            }

            void Unity_Add_float4(float4 A, float4 B, out float4 Out)
            {
                Out = A + B;
            }

            void Unity_FresnelEffect_float(float3 Normal, float3 ViewDir, float Power, out float Out)
            {
                Out = pow((1.0 - saturate(dot(normalize(Normal), normalize(ViewDir)))), Power);
            }

            void Unity_Lerp_float4(float4 A, float4 B, float4 T, out float4 Out)
            {
                Out = lerp(A, B, T);
            }

            void Unity_Subtract_float3(float3 A, float3 B, out float3 Out)
            {
                Out = A - B;
            }

            void Unity_DotProduct_float3(float3 A, float3 B, out float Out)
            {
                Out = dot(A, B);
            }

            void Unity_Remap_float(float In, float2 InMinMax, float2 OutMinMax, out float Out)
            {
                Out = OutMinMax.x + (In - InMinMax.x) * (OutMinMax.y - OutMinMax.x) / (InMinMax.y - InMinMax.x);
            }

            void Unity_Add_float(float A, float B, out float Out)
            {
                Out = A + B;
            }

            void Unity_SceneDepth_Linear01_float(float4 UV, out float Out)
            {
                Out = Linear01Depth(SHADERGRAPH_SAMPLE_SCENE_DEPTH(UV.xy), _ZBufferParams);
            }

            void Unity_Smoothstep_float(float Edge1, float Edge2, float In, out float Out)
            {
                Out = smoothstep(Edge1, Edge2, In);
            }

            void Unity_Clamp_float(float In, float Min, float Max, out float Out)
            {
                Out = clamp(In, Min, Max);
            }

            void Unity_OneMinus_float(float In, out float Out)
            {
                Out = 1 - In;
            }

            struct VertexDescription
            {
                float3 Position;
            };

            VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
            {
                VertexDescription description = (VertexDescription)0;
                float _Split_49E7322C_R = IN.WorldSpacePosition[0];
                float _Split_49E7322C_G = IN.WorldSpacePosition[1];
                float _Split_49E7322C_B = IN.WorldSpacePosition[2];
                float _Split_49E7322C_A = 0;
                float4 _Combine_690F97BF_RGBA;
                float3 _Combine_690F97BF_RGB;
                float2 _Combine_690F97BF_RG;
                Unity_Combine_float(_Split_49E7322C_R, _Split_49E7322C_B, 0, 0, _Combine_690F97BF_RGBA, _Combine_690F97BF_RGB, _Combine_690F97BF_RG);
                float _Property_27AA5723_Out = Vector1_221A0FD9;
                float2 _Multiply_9915511D_Out;
                Unity_Multiply_float(_Combine_690F97BF_RG, (_Property_27AA5723_Out.xx), _Multiply_9915511D_Out);

                float _Property_5062A5B0_Out = Vector1_33B63372;
                float _Multiply_8B6F13FF_Out;
                Unity_Multiply_float(_Time.y, _Property_5062A5B0_Out, _Multiply_8B6F13FF_Out);

                float2 _TilingAndOffset_C1E9B602_Out;
                Unity_TilingAndOffset_float(_Multiply_9915511D_Out, float2 (1,1), (_Multiply_8B6F13FF_Out.xx), _TilingAndOffset_C1E9B602_Out);
                float _Property_1713DFB6_Out = Vector1_252B0398;
                float _GradientNoise_7C6CFF22_Out;
                Unity_GradientNoise_float(_TilingAndOffset_C1E9B602_Out, _Property_1713DFB6_Out, _GradientNoise_7C6CFF22_Out);
                float3 _Multiply_324A9939_Out;
                Unity_Multiply_float(IN.WorldSpaceNormal, (_GradientNoise_7C6CFF22_Out.xxx), _Multiply_324A9939_Out);

                float3 _Add_84DFD690_Out;
                Unity_Add_float3(_Multiply_324A9939_Out, IN.ObjectSpacePosition, _Add_84DFD690_Out);
                description.Position = _Add_84DFD690_Out;
                return description;
            }

            struct SurfaceDescription
            {
                float3 Albedo;
                float3 Normal;
                float3 Emission;
                float Metallic;
                float Smoothness;
                float Occlusion;
                float Alpha;
                float AlphaClipThreshold;
            };

            SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
            {
                SurfaceDescription surface = (SurfaceDescription)0;
                float4 _Property_23FE3CE_Out = Color_BF3303A0;
                float _Split_B9847336_R = IN.WorldSpacePosition[0];
                float _Split_B9847336_G = IN.WorldSpacePosition[1];
                float _Split_B9847336_B = IN.WorldSpacePosition[2];
                float _Split_B9847336_A = 0;
                float4 _Combine_EE24E6F2_RGBA;
                float3 _Combine_EE24E6F2_RGB;
                float2 _Combine_EE24E6F2_RG;
                Unity_Combine_float(_Split_B9847336_R, _Split_B9847336_B, 0, 0, _Combine_EE24E6F2_RGBA, _Combine_EE24E6F2_RGB, _Combine_EE24E6F2_RG);
                float _Property_EA233F6C_Out = Vector1_221A0FD9;
                float2 _Multiply_5FBCC94C_Out;
                Unity_Multiply_float(_Combine_EE24E6F2_RG, (_Property_EA233F6C_Out.xx), _Multiply_5FBCC94C_Out);

                float _Property_E794697D_Out = Vector1_3E734ED8;
                float _Multiply_F27D3501_Out;
                Unity_Multiply_float(_Time.y, _Property_E794697D_Out, _Multiply_F27D3501_Out);

                float _Property_DF2E142D_Out = Vector1_30FC0A4B;
                float _Voronoi_EDF64014_Out;
                float _Voronoi_EDF64014_Cells;
                Unity_Voronoi_float(_Multiply_5FBCC94C_Out, _Multiply_F27D3501_Out, _Property_DF2E142D_Out, _Voronoi_EDF64014_Out, _Voronoi_EDF64014_Cells);
                float _Property_F9D7714D_Out = Vector1_8FDC4159;
                float _Power_B15F028A_Out;
                Unity_Power_float(_Voronoi_EDF64014_Out, _Property_F9D7714D_Out, _Power_B15F028A_Out);
                float4 _Property_7F4EBE75_Out = Color_5856042A;
                float4 _Multiply_73F5CD9F_Out;
                Unity_Multiply_float((_Power_B15F028A_Out.xxxx), _Property_7F4EBE75_Out, _Multiply_73F5CD9F_Out);

                float4 _Add_CA03B711_Out;
                Unity_Add_float4(_Property_23FE3CE_Out, _Multiply_73F5CD9F_Out, _Add_CA03B711_Out);
                float4 Color_99AF311E = IsGammaSpace() ? float4(0.3160377, 0.8424633, 1, 0) : float4(SRGBToLinear(float3(0.3160377, 0.8424633, 1)), 0);
                float4 Color_10D69FE0 = IsGammaSpace() ? float4(0, 0.229, 0.1605632, 0) : float4(SRGBToLinear(float3(0, 0.229, 0.1605632)), 0);
                float _FresnelEffect_50DAADA4_Out;
                Unity_FresnelEffect_float(IN.WorldSpaceNormal, IN.WorldSpaceViewDirection, 1, _FresnelEffect_50DAADA4_Out);
                float4 _Lerp_E847765E_Out;
                Unity_Lerp_float4(Color_99AF311E, Color_10D69FE0, (_FresnelEffect_50DAADA4_Out.xxxx), _Lerp_E847765E_Out);
                float4 _Add_D22EED0_Out;
                Unity_Add_float4(_Add_CA03B711_Out, _Lerp_E847765E_Out, _Add_D22EED0_Out);
                float4 _Add_26EF4CB1_Out;
                Unity_Add_float4(_Add_D22EED0_Out, float4(0, 0, 0, 0), _Add_26EF4CB1_Out);
                float3 _Subtract_1A6292B4_Out;
                Unity_Subtract_float3(IN.WorldSpacePosition, _WorldSpaceCameraPos, _Subtract_1A6292B4_Out);
                float _DotProduct_FCEA7241_Out;
                Unity_DotProduct_float3(-1 * mul(UNITY_MATRIX_M, transpose(mul(UNITY_MATRIX_I_M, UNITY_MATRIX_I_V)) [2].xyz), _Subtract_1A6292B4_Out, _DotProduct_FCEA7241_Out);
                float2 _Vector2_66B2C374_Out = float2(0,_ProjectionParams.z);
                float _Remap_DE2C36AE_Out;
                Unity_Remap_float(_DotProduct_FCEA7241_Out, _Vector2_66B2C374_Out, float2 (0,1), _Remap_DE2C36AE_Out);
                float _Property_514FC065_Out = Vector1_1B7394EE;
                float _Add_569553BC_Out;
                Unity_Add_float(_DotProduct_FCEA7241_Out, _Property_514FC065_Out, _Add_569553BC_Out);
                float _Remap_711563B3_Out;
                Unity_Remap_float(_Add_569553BC_Out, _Vector2_66B2C374_Out, float2 (0,1), _Remap_711563B3_Out);
                float _SceneDepth_F365D371_Out;
                Unity_SceneDepth_Linear01_float(float4(IN.ScreenPosition.xy / IN.ScreenPosition.w, 0, 0), _SceneDepth_F365D371_Out);
                float _Smoothstep_84E11D33_Out;
                Unity_Smoothstep_float(_Remap_DE2C36AE_Out, _Remap_711563B3_Out, _SceneDepth_F365D371_Out, _Smoothstep_84E11D33_Out);
                float _Split_7D04ED44_R = IN.WorldSpacePosition[0];
                float _Split_7D04ED44_G = IN.WorldSpacePosition[1];
                float _Split_7D04ED44_B = IN.WorldSpacePosition[2];
                float _Split_7D04ED44_A = 0;
                float4 _Combine_CA14ABE5_RGBA;
                float3 _Combine_CA14ABE5_RGB;
                float2 _Combine_CA14ABE5_RG;
                Unity_Combine_float(_Split_7D04ED44_R, _Split_7D04ED44_B, 0, 0, _Combine_CA14ABE5_RGBA, _Combine_CA14ABE5_RGB, _Combine_CA14ABE5_RG);
                float _Property_459A4526_Out = Vector1_221A0FD9;
                float2 _Multiply_49F38EDE_Out;
                Unity_Multiply_float(_Combine_CA14ABE5_RG, (_Property_459A4526_Out.xx), _Multiply_49F38EDE_Out);

                float _Property_2AB2E5A3_Out = Vector1_917CCD13;
                float _Multiply_8E4C8E2_Out;
                Unity_Multiply_float(_Time.y, _Property_2AB2E5A3_Out, _Multiply_8E4C8E2_Out);

                float2 _TilingAndOffset_2A152B1_Out;
                Unity_TilingAndOffset_float(_Multiply_49F38EDE_Out, float2 (1,1), (_Multiply_8E4C8E2_Out.xx), _TilingAndOffset_2A152B1_Out);
                float _Property_86A70B0B_Out = Vector1_4A68B0E6;
                float _GradientNoise_A48547B4_Out;
                Unity_GradientNoise_float(_TilingAndOffset_2A152B1_Out, _Property_86A70B0B_Out, _GradientNoise_A48547B4_Out);
                float _Property_C544BFEC_Out = Vector1_C3288503;
                float _Clamp_1FFEF810_Out;
                Unity_Clamp_float(_GradientNoise_A48547B4_Out, _Property_C544BFEC_Out, 1, _Clamp_1FFEF810_Out);
                float _Add_BA7C5D1D_Out;
                Unity_Add_float(_Smoothstep_84E11D33_Out, _Clamp_1FFEF810_Out, _Add_BA7C5D1D_Out);
                float _Clamp_BCB4F689_Out;
                Unity_Clamp_float(_Add_BA7C5D1D_Out, 0, 1, _Clamp_BCB4F689_Out);
                float _OneMinus_9D425443_Out;
                Unity_OneMinus_float(_Clamp_BCB4F689_Out, _OneMinus_9D425443_Out);
                float _Vector1_B9E10D48_Out = 0.3;
                float _Property_888F2FB1_Out = Vector1_E567A086;
                float _Property_DAB033DB_Out = Vector1_F2B54871;
                surface.Albedo = (_Add_26EF4CB1_Out.xyz);
                surface.Normal = IN.TangentSpaceNormal;
                surface.Emission = (_OneMinus_9D425443_Out.xxx);
                surface.Metallic = _Vector1_B9E10D48_Out;
                surface.Smoothness = _Property_888F2FB1_Out;
                surface.Occlusion = 1;
                surface.Alpha = _Property_DAB033DB_Out;
                surface.AlphaClipThreshold = 0.5;
                return surface;
            }

            struct GraphVertexInput
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                float4 texcoord1 : TEXCOORD1;
                UNITY_VERTEX_INPUT_INSTANCE_ID
            };


        	struct GraphVertexOutput
            {
                float4 clipPos                : SV_POSITION;
                DECLARE_LIGHTMAP_OR_SH(lightmapUV, vertexSH, 0);
        		half4 fogFactorAndVertexLight : TEXCOORD1; // x: fogFactor, yzw: vertex light
            	float4 shadowCoord            : TEXCOORD2;

        		// Interpolators defined by graph
                float3 WorldSpacePosition : TEXCOORD3;
                float3 WorldSpaceNormal : TEXCOORD4;
                float3 WorldSpaceTangent : TEXCOORD5;
                float3 WorldSpaceBiTangent : TEXCOORD6;
                float3 WorldSpaceViewDirection : TEXCOORD7;
                float4 ScreenPosition : TEXCOORD8;
                half4 uv1 : TEXCOORD9;

                UNITY_VERTEX_INPUT_INSTANCE_ID
            	UNITY_VERTEX_OUTPUT_STEREO
            };

            GraphVertexOutput vert (GraphVertexInput v)
        	{
        		GraphVertexOutput o = (GraphVertexOutput)0;
                UNITY_SETUP_INSTANCE_ID(v);
            	UNITY_TRANSFER_INSTANCE_ID(v, o);
        		UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

        		// Vertex transformations performed by graph
                float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
                float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
                float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
                float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
                float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
                float4 ScreenPosition = ComputeScreenPos(mul(GetWorldToHClipMatrix(), mul(GetObjectToWorldMatrix(), v.vertex)), _ProjectionParams.x);
                float4 uv1 = v.texcoord1;
                float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;

        		VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

        		// Vertex description inputs defined by graph
                vdi.WorldSpaceNormal = WorldSpaceNormal;
                vdi.ObjectSpacePosition = ObjectSpacePosition;
                vdi.WorldSpacePosition = WorldSpacePosition;

        	    VertexDescription vd = PopulateVertexData(vdi);
        		v.vertex.xyz = vd.Position;

                // Update Screenposition for new vertex position
                ScreenPosition = ComputeScreenPos(mul(GetWorldToHClipMatrix(), mul(GetObjectToWorldMatrix(), v.vertex)), _ProjectionParams.x);

        		// Vertex shader outputs defined by graph
                o.WorldSpacePosition = WorldSpacePosition;
                o.WorldSpaceNormal = WorldSpaceNormal;
                o.WorldSpaceTangent = WorldSpaceTangent;
                o.WorldSpaceBiTangent = WorldSpaceBiTangent;
                o.WorldSpaceViewDirection = WorldSpaceViewDirection;
                o.ScreenPosition = ScreenPosition;
                o.uv1 = uv1;

        		float3 lwWNormal = TransformObjectToWorldNormal(v.normal);

                VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);
                
         		// We either sample GI from lightmap or SH.
        	    // Lightmap UV and vertex SH coefficients use the same interpolator ("float2 lightmapUV" for lightmap or "half3 vertexSH" for SH)
                // see DECLARE_LIGHTMAP_OR_SH macro.
        	    // The following funcions initialize the correct variable with correct data
        	    OUTPUT_LIGHTMAP_UV(v.texcoord1, unity_LightmapST, o.lightmapUV);
        	    OUTPUT_SH(lwWNormal, o.vertexSH);

        	    half3 vertexLight = VertexLighting(vertexInput.positionWS, lwWNormal);
        	    half fogFactor = ComputeFogFactor(vertexInput.positionCS.z);
        	    o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);
        	    o.clipPos = vertexInput.positionCS;

        	#ifdef _MAIN_LIGHT_SHADOWS
        		o.shadowCoord = GetShadowCoord(vertexInput);
        	#endif
        		return o;
        	}

        	half4 frag (GraphVertexOutput IN ) : SV_Target
            {
            	UNITY_SETUP_INSTANCE_ID(IN);
        		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);

        		// Pixel transformations performed by graph
                float3 WorldSpacePosition = IN.WorldSpacePosition;
                float3 WorldSpaceNormal = IN.WorldSpaceNormal;
                float3 WorldSpaceTangent = IN.WorldSpaceTangent;
                float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
                float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
                float3x3 tangentSpaceTransform = float3x3(WorldSpaceTangent,WorldSpaceBiTangent,WorldSpaceNormal);
                float4 ScreenPosition = IN.ScreenPosition;
                float4 uv1 = IN.uv1;
                float3 TangentSpaceNormal = mul(WorldSpaceNormal,(float3x3)tangentSpaceTransform).xyz;

                SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

        		// Surface description inputs defined by graph
                surfaceInput.WorldSpaceNormal = WorldSpaceNormal;
                surfaceInput.TangentSpaceNormal = TangentSpaceNormal;
                surfaceInput.WorldSpaceViewDirection = WorldSpaceViewDirection;
                surfaceInput.WorldSpacePosition = WorldSpacePosition;
                surfaceInput.ScreenPosition = ScreenPosition;

                SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

        		float3 Albedo = float3(0.5, 0.5, 0.5);
        		float3 Specular = float3(0, 0, 0);
        		float Metallic = 1;
        		float3 Normal = float3(0, 0, 1);
        		float3 Emission = 0;
        		float Smoothness = 0.5;
        		float Occlusion = 1;
        		float Alpha = 1;
        		float AlphaClipThreshold = 0;

        		// Surface description remap performed by graph
                Albedo = surf.Albedo;
                Normal = surf.Normal;
                Emission = surf.Emission;
                Metallic = surf.Metallic;
                Smoothness = surf.Smoothness;
                Occlusion = surf.Occlusion;
                Alpha = surf.Alpha;
                AlphaClipThreshold = surf.AlphaClipThreshold;

        		InputData inputData;
        		inputData.positionWS = WorldSpacePosition;

        #ifdef _NORMALMAP
        	    inputData.normalWS = normalize(TransformTangentToWorld(Normal, half3x3(WorldSpaceTangent, WorldSpaceBiTangent, WorldSpaceNormal)));
        #else
            #if !SHADER_HINT_NICE_QUALITY
                inputData.normalWS = WorldSpaceNormal;
            #else
        	    inputData.normalWS = normalize(WorldSpaceNormal);
            #endif
        #endif

        #if !SHADER_HINT_NICE_QUALITY
        	    // viewDirection should be normalized here, but we avoid doing it as it's close enough and we save some ALU.
        	    inputData.viewDirectionWS = WorldSpaceViewDirection;
        #else
        	    inputData.viewDirectionWS = normalize(WorldSpaceViewDirection);
        #endif

        	    inputData.shadowCoord = IN.shadowCoord;

        	    inputData.fogCoord = IN.fogFactorAndVertexLight.x;
        	    inputData.vertexLighting = IN.fogFactorAndVertexLight.yzw;
        	    inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.vertexSH, inputData.normalWS);

        		half4 color = LightweightFragmentPBR(
        			inputData, 
        			Albedo, 
        			Metallic, 
        			Specular, 
        			Smoothness, 
        			Occlusion, 
        			Emission, 
        			Alpha);

        		// Computes fog factor per-vertex
            	color.rgb = MixFog(color.rgb, IN.fogFactorAndVertexLight.x);

        #if _AlphaClip
        		clip(Alpha - AlphaClipThreshold);
        #endif
        		return color;
            }

        	ENDHLSL
        }
        Pass
        {
        	Name "ShadowCaster"
            Tags{"LightMode" = "ShadowCaster"}

            ZWrite On ZTest LEqual

            // Material options generated by graph
            Cull Back

            HLSLPROGRAM
            // Required to compile gles 2.0 with standard srp library
            #pragma prefer_hlslcc gles
            #pragma exclude_renderers d3d11_9x
            #pragma target 2.0

            //--------------------------------------
            // GPU Instancing
            #pragma multi_compile_instancing

            #pragma vertex ShadowPassVertex
            #pragma fragment ShadowPassFragment

            // Defines generated by graph
            #define REQUIRE_DEPTH_TEXTURE

            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl"
            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"

            CBUFFER_START(UnityPerMaterial)
            float4 Color_BF3303A0;
            float Vector1_E567A086;
            float Vector1_F2B54871;
            float Vector1_221A0FD9;
            float Vector1_3E734ED8;
            float Vector1_30FC0A4B;
            float Vector1_8FDC4159;
            float4 Color_5856042A;
            float Vector1_33B63372;
            float Vector1_252B0398;
            float Vector1_1B7394EE;
            float Vector1_C3288503;
            float Vector1_4A68B0E6;
            float Vector1_917CCD13;
            CBUFFER_END


            struct VertexDescriptionInputs
            {
                float3 WorldSpaceNormal;
                float3 ObjectSpacePosition;
                float3 WorldSpacePosition;
            };

            struct SurfaceDescriptionInputs
            {
                float3 WorldSpaceNormal;
                float3 TangentSpaceNormal;
                float3 WorldSpaceViewDirection;
                float3 WorldSpacePosition;
                float4 ScreenPosition;
            };


            void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
            {
                RGBA = float4(R, G, B, A);
                RGB = float3(R, G, B);
                RG = float2(R, G);
            }

            void Unity_Multiply_float (float2 A, float2 B, out float2 Out)
            {
                Out = A * B;
            }

            void Unity_Multiply_float (float A, float B, out float Out)
            {
                Out = A * B;
            }

            void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
            {
                Out = UV * Tiling + Offset;
            }


        float2 unity_gradientNoise_dir(float2 p)
        {
            // Permutation and hashing used in webgl-nosie goo.gl/pX7HtC
            p = p % 289;
            float x = (34 * p.x + 1) * p.x % 289 + p.y;
            x = (34 * x + 1) * x % 289;
            x = frac(x / 41) * 2 - 1;
            return normalize(float2(x - floor(x + 0.5), abs(x) - 0.5));
        }


        float unity_gradientNoise(float2 p)
        {
            float2 ip = floor(p);
            float2 fp = frac(p);
            float d00 = dot(unity_gradientNoise_dir(ip), fp);
            float d01 = dot(unity_gradientNoise_dir(ip + float2(0, 1)), fp - float2(0, 1));
            float d10 = dot(unity_gradientNoise_dir(ip + float2(1, 0)), fp - float2(1, 0));
            float d11 = dot(unity_gradientNoise_dir(ip + float2(1, 1)), fp - float2(1, 1));
            fp = fp * fp * fp * (fp * (fp * 6 - 15) + 10);
            return lerp(lerp(d00, d01, fp.y), lerp(d10, d11, fp.y), fp.x);
        }

            void Unity_GradientNoise_float(float2 UV, float Scale, out float Out)
            { Out = unity_gradientNoise(UV * Scale) + 0.5; }

            void Unity_Multiply_float (float3 A, float3 B, out float3 Out)
            {
                Out = A * B;
            }

            void Unity_Add_float3(float3 A, float3 B, out float3 Out)
            {
                Out = A + B;
            }


        inline float2 unity_voronoi_noise_randomVector (float2 UV, float offset)
        {
            float2x2 m = float2x2(15.27, 47.63, 99.41, 89.98);
            UV = frac(sin(mul(UV, m)) * 46839.32);
            return float2(sin(UV.y*+offset)*0.5+0.5, cos(UV.x*offset)*0.5+0.5);
        }

            void Unity_Voronoi_float(float2 UV, float AngleOffset, float CellDensity, out float Out, out float Cells)
            {
                float2 g = floor(UV * CellDensity);
                float2 f = frac(UV * CellDensity);
                float t = 8.0;
                float3 res = float3(8.0, 0.0, 0.0);

                for(int y=-1; y<=1; y++)
                {
                    for(int x=-1; x<=1; x++)
                    {
                        float2 lattice = float2(x,y);
                        float2 offset = unity_voronoi_noise_randomVector(lattice + g, AngleOffset);
                        float d = distance(lattice + offset, f);

                        if(d < res.x)
                        {

                            res = float3(d, offset.x, offset.y);
                            Out = res.x;
                            Cells = res.y;

                        }
                    }

                }

            }

            void Unity_Power_float(float A, float B, out float Out)
            {
                Out = pow(A, B);
            }

            void Unity_Multiply_float (float4 A, float4 B, out float4 Out)
            {
                Out = A * B;
            }

            void Unity_Add_float4(float4 A, float4 B, out float4 Out)
            {
                Out = A + B;
            }

            void Unity_FresnelEffect_float(float3 Normal, float3 ViewDir, float Power, out float Out)
            {
                Out = pow((1.0 - saturate(dot(normalize(Normal), normalize(ViewDir)))), Power);
            }

            void Unity_Lerp_float4(float4 A, float4 B, float4 T, out float4 Out)
            {
                Out = lerp(A, B, T);
            }

            void Unity_Subtract_float3(float3 A, float3 B, out float3 Out)
            {
                Out = A - B;
            }

            void Unity_DotProduct_float3(float3 A, float3 B, out float Out)
            {
                Out = dot(A, B);
            }

            void Unity_Remap_float(float In, float2 InMinMax, float2 OutMinMax, out float Out)
            {
                Out = OutMinMax.x + (In - InMinMax.x) * (OutMinMax.y - OutMinMax.x) / (InMinMax.y - InMinMax.x);
            }

            void Unity_Add_float(float A, float B, out float Out)
            {
                Out = A + B;
            }

            void Unity_SceneDepth_Linear01_float(float4 UV, out float Out)
            {
                Out = Linear01Depth(SHADERGRAPH_SAMPLE_SCENE_DEPTH(UV.xy), _ZBufferParams);
            }

            void Unity_Smoothstep_float(float Edge1, float Edge2, float In, out float Out)
            {
                Out = smoothstep(Edge1, Edge2, In);
            }

            void Unity_Clamp_float(float In, float Min, float Max, out float Out)
            {
                Out = clamp(In, Min, Max);
            }

            void Unity_OneMinus_float(float In, out float Out)
            {
                Out = 1 - In;
            }

            struct VertexDescription
            {
                float3 Position;
            };

            VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
            {
                VertexDescription description = (VertexDescription)0;
                float _Split_49E7322C_R = IN.WorldSpacePosition[0];
                float _Split_49E7322C_G = IN.WorldSpacePosition[1];
                float _Split_49E7322C_B = IN.WorldSpacePosition[2];
                float _Split_49E7322C_A = 0;
                float4 _Combine_690F97BF_RGBA;
                float3 _Combine_690F97BF_RGB;
                float2 _Combine_690F97BF_RG;
                Unity_Combine_float(_Split_49E7322C_R, _Split_49E7322C_B, 0, 0, _Combine_690F97BF_RGBA, _Combine_690F97BF_RGB, _Combine_690F97BF_RG);
                float _Property_27AA5723_Out = Vector1_221A0FD9;
                float2 _Multiply_9915511D_Out;
                Unity_Multiply_float(_Combine_690F97BF_RG, (_Property_27AA5723_Out.xx), _Multiply_9915511D_Out);

                float _Property_5062A5B0_Out = Vector1_33B63372;
                float _Multiply_8B6F13FF_Out;
                Unity_Multiply_float(_Time.y, _Property_5062A5B0_Out, _Multiply_8B6F13FF_Out);

                float2 _TilingAndOffset_C1E9B602_Out;
                Unity_TilingAndOffset_float(_Multiply_9915511D_Out, float2 (1,1), (_Multiply_8B6F13FF_Out.xx), _TilingAndOffset_C1E9B602_Out);
                float _Property_1713DFB6_Out = Vector1_252B0398;
                float _GradientNoise_7C6CFF22_Out;
                Unity_GradientNoise_float(_TilingAndOffset_C1E9B602_Out, _Property_1713DFB6_Out, _GradientNoise_7C6CFF22_Out);
                float3 _Multiply_324A9939_Out;
                Unity_Multiply_float(IN.WorldSpaceNormal, (_GradientNoise_7C6CFF22_Out.xxx), _Multiply_324A9939_Out);

                float3 _Add_84DFD690_Out;
                Unity_Add_float3(_Multiply_324A9939_Out, IN.ObjectSpacePosition, _Add_84DFD690_Out);
                description.Position = _Add_84DFD690_Out;
                return description;
            }

            struct SurfaceDescription
            {
                float3 Albedo;
                float3 Emission;
                float Alpha;
                float AlphaClipThreshold;
            };

            SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
            {
                SurfaceDescription surface = (SurfaceDescription)0;
                float4 _Property_23FE3CE_Out = Color_BF3303A0;
                float _Split_B9847336_R = IN.WorldSpacePosition[0];
                float _Split_B9847336_G = IN.WorldSpacePosition[1];
                float _Split_B9847336_B = IN.WorldSpacePosition[2];
                float _Split_B9847336_A = 0;
                float4 _Combine_EE24E6F2_RGBA;
                float3 _Combine_EE24E6F2_RGB;
                float2 _Combine_EE24E6F2_RG;
                Unity_Combine_float(_Split_B9847336_R, _Split_B9847336_B, 0, 0, _Combine_EE24E6F2_RGBA, _Combine_EE24E6F2_RGB, _Combine_EE24E6F2_RG);
                float _Property_EA233F6C_Out = Vector1_221A0FD9;
                float2 _Multiply_5FBCC94C_Out;
                Unity_Multiply_float(_Combine_EE24E6F2_RG, (_Property_EA233F6C_Out.xx), _Multiply_5FBCC94C_Out);

                float _Property_E794697D_Out = Vector1_3E734ED8;
                float _Multiply_F27D3501_Out;
                Unity_Multiply_float(_Time.y, _Property_E794697D_Out, _Multiply_F27D3501_Out);

                float _Property_DF2E142D_Out = Vector1_30FC0A4B;
                float _Voronoi_EDF64014_Out;
                float _Voronoi_EDF64014_Cells;
                Unity_Voronoi_float(_Multiply_5FBCC94C_Out, _Multiply_F27D3501_Out, _Property_DF2E142D_Out, _Voronoi_EDF64014_Out, _Voronoi_EDF64014_Cells);
                float _Property_F9D7714D_Out = Vector1_8FDC4159;
                float _Power_B15F028A_Out;
                Unity_Power_float(_Voronoi_EDF64014_Out, _Property_F9D7714D_Out, _Power_B15F028A_Out);
                float4 _Property_7F4EBE75_Out = Color_5856042A;
                float4 _Multiply_73F5CD9F_Out;
                Unity_Multiply_float((_Power_B15F028A_Out.xxxx), _Property_7F4EBE75_Out, _Multiply_73F5CD9F_Out);

                float4 _Add_CA03B711_Out;
                Unity_Add_float4(_Property_23FE3CE_Out, _Multiply_73F5CD9F_Out, _Add_CA03B711_Out);
                float4 Color_99AF311E = IsGammaSpace() ? float4(0.3160377, 0.8424633, 1, 0) : float4(SRGBToLinear(float3(0.3160377, 0.8424633, 1)), 0);
                float4 Color_10D69FE0 = IsGammaSpace() ? float4(0, 0.229, 0.1605632, 0) : float4(SRGBToLinear(float3(0, 0.229, 0.1605632)), 0);
                float _FresnelEffect_50DAADA4_Out;
                Unity_FresnelEffect_float(IN.WorldSpaceNormal, IN.WorldSpaceViewDirection, 1, _FresnelEffect_50DAADA4_Out);
                float4 _Lerp_E847765E_Out;
                Unity_Lerp_float4(Color_99AF311E, Color_10D69FE0, (_FresnelEffect_50DAADA4_Out.xxxx), _Lerp_E847765E_Out);
                float4 _Add_D22EED0_Out;
                Unity_Add_float4(_Add_CA03B711_Out, _Lerp_E847765E_Out, _Add_D22EED0_Out);
                float4 _Add_26EF4CB1_Out;
                Unity_Add_float4(_Add_D22EED0_Out, float4(0, 0, 0, 0), _Add_26EF4CB1_Out);
                float3 _Subtract_1A6292B4_Out;
                Unity_Subtract_float3(IN.WorldSpacePosition, _WorldSpaceCameraPos, _Subtract_1A6292B4_Out);
                float _DotProduct_FCEA7241_Out;
                Unity_DotProduct_float3(-1 * mul(UNITY_MATRIX_M, transpose(mul(UNITY_MATRIX_I_M, UNITY_MATRIX_I_V)) [2].xyz), _Subtract_1A6292B4_Out, _DotProduct_FCEA7241_Out);
                float2 _Vector2_66B2C374_Out = float2(0,_ProjectionParams.z);
                float _Remap_DE2C36AE_Out;
                Unity_Remap_float(_DotProduct_FCEA7241_Out, _Vector2_66B2C374_Out, float2 (0,1), _Remap_DE2C36AE_Out);
                float _Property_514FC065_Out = Vector1_1B7394EE;
                float _Add_569553BC_Out;
                Unity_Add_float(_DotProduct_FCEA7241_Out, _Property_514FC065_Out, _Add_569553BC_Out);
                float _Remap_711563B3_Out;
                Unity_Remap_float(_Add_569553BC_Out, _Vector2_66B2C374_Out, float2 (0,1), _Remap_711563B3_Out);
                float _SceneDepth_F365D371_Out;
                Unity_SceneDepth_Linear01_float(float4(IN.ScreenPosition.xy / IN.ScreenPosition.w, 0, 0), _SceneDepth_F365D371_Out);
                float _Smoothstep_84E11D33_Out;
                Unity_Smoothstep_float(_Remap_DE2C36AE_Out, _Remap_711563B3_Out, _SceneDepth_F365D371_Out, _Smoothstep_84E11D33_Out);
                float _Split_7D04ED44_R = IN.WorldSpacePosition[0];
                float _Split_7D04ED44_G = IN.WorldSpacePosition[1];
                float _Split_7D04ED44_B = IN.WorldSpacePosition[2];
                float _Split_7D04ED44_A = 0;
                float4 _Combine_CA14ABE5_RGBA;
                float3 _Combine_CA14ABE5_RGB;
                float2 _Combine_CA14ABE5_RG;
                Unity_Combine_float(_Split_7D04ED44_R, _Split_7D04ED44_B, 0, 0, _Combine_CA14ABE5_RGBA, _Combine_CA14ABE5_RGB, _Combine_CA14ABE5_RG);
                float _Property_459A4526_Out = Vector1_221A0FD9;
                float2 _Multiply_49F38EDE_Out;
                Unity_Multiply_float(_Combine_CA14ABE5_RG, (_Property_459A4526_Out.xx), _Multiply_49F38EDE_Out);

                float _Property_2AB2E5A3_Out = Vector1_917CCD13;
                float _Multiply_8E4C8E2_Out;
                Unity_Multiply_float(_Time.y, _Property_2AB2E5A3_Out, _Multiply_8E4C8E2_Out);

                float2 _TilingAndOffset_2A152B1_Out;
                Unity_TilingAndOffset_float(_Multiply_49F38EDE_Out, float2 (1,1), (_Multiply_8E4C8E2_Out.xx), _TilingAndOffset_2A152B1_Out);
                float _Property_86A70B0B_Out = Vector1_4A68B0E6;
                float _GradientNoise_A48547B4_Out;
                Unity_GradientNoise_float(_TilingAndOffset_2A152B1_Out, _Property_86A70B0B_Out, _GradientNoise_A48547B4_Out);
                float _Property_C544BFEC_Out = Vector1_C3288503;
                float _Clamp_1FFEF810_Out;
                Unity_Clamp_float(_GradientNoise_A48547B4_Out, _Property_C544BFEC_Out, 1, _Clamp_1FFEF810_Out);
                float _Add_BA7C5D1D_Out;
                Unity_Add_float(_Smoothstep_84E11D33_Out, _Clamp_1FFEF810_Out, _Add_BA7C5D1D_Out);
                float _Clamp_BCB4F689_Out;
                Unity_Clamp_float(_Add_BA7C5D1D_Out, 0, 1, _Clamp_BCB4F689_Out);
                float _OneMinus_9D425443_Out;
                Unity_OneMinus_float(_Clamp_BCB4F689_Out, _OneMinus_9D425443_Out);
                float _Property_DAB033DB_Out = Vector1_F2B54871;
                surface.Albedo = (_Add_26EF4CB1_Out.xyz);
                surface.Emission = (_OneMinus_9D425443_Out.xxx);
                surface.Alpha = _Property_DAB033DB_Out;
                surface.AlphaClipThreshold = 0.5;
                return surface;
            }

            struct GraphVertexInput
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                float4 texcoord1 : TEXCOORD1;
                UNITY_VERTEX_INPUT_INSTANCE_ID
            };


        	struct VertexOutput
        	{
        	    float2 uv           : TEXCOORD0;
        	    float4 clipPos      : SV_POSITION;
                // Interpolators defined by graph
                float3 WorldSpacePosition : TEXCOORD3;
                float3 WorldSpaceNormal : TEXCOORD4;
                float3 WorldSpaceTangent : TEXCOORD5;
                float3 WorldSpaceBiTangent : TEXCOORD6;
                float3 WorldSpaceViewDirection : TEXCOORD7;
                float4 ScreenPosition : TEXCOORD8;
                half4 uv1 : TEXCOORD9;

                UNITY_VERTEX_INPUT_INSTANCE_ID
        	};

            float3 _LightDirection;

            VertexOutput ShadowPassVertex(GraphVertexInput v)
        	{
        	    VertexOutput o;
        	    UNITY_SETUP_INSTANCE_ID(v);
                UNITY_TRANSFER_INSTANCE_ID(v, o);

                // Vertex transformations performed by graph
                float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
                float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
                float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
                float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
                float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
                float4 ScreenPosition = ComputeScreenPos(mul(GetWorldToHClipMatrix(), mul(GetObjectToWorldMatrix(), v.vertex)), _ProjectionParams.x);
                float4 uv1 = v.texcoord1;
                float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;

        		VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

                // Vertex description inputs defined by graph
                vdi.WorldSpaceNormal = WorldSpaceNormal;
                vdi.ObjectSpacePosition = ObjectSpacePosition;
                vdi.WorldSpacePosition = WorldSpacePosition;

        	    VertexDescription vd = PopulateVertexData(vdi);
                v.vertex.xyz = vd.Position;

                ScreenPosition = ComputeScreenPos(mul(GetWorldToHClipMatrix(), mul(GetObjectToWorldMatrix(), v.vertex)), _ProjectionParams.x);

        	    // Vertex shader outputs defined by graph
                o.WorldSpacePosition = WorldSpacePosition;
                o.WorldSpaceNormal = WorldSpaceNormal;
                o.WorldSpaceTangent = WorldSpaceTangent;
                o.WorldSpaceBiTangent = WorldSpaceBiTangent;
                o.WorldSpaceViewDirection = WorldSpaceViewDirection;
                o.ScreenPosition = ScreenPosition;
                o.uv1 = uv1;

        	    
        	    float3 positionWS = TransformObjectToWorld(v.vertex.xyz);
                float3 normalWS = TransformObjectToWorldNormal(v.normal);

                float4 clipPos = TransformWorldToHClip(ApplyShadowBias(positionWS, normalWS, _LightDirection));

        	#if UNITY_REVERSED_Z
        	    clipPos.z = min(clipPos.z, clipPos.w * UNITY_NEAR_CLIP_VALUE);
        	#else
        	    clipPos.z = max(clipPos.z, clipPos.w * UNITY_NEAR_CLIP_VALUE);
        	#endif
                o.clipPos = clipPos;

        	    return o;
        	}

            half4 ShadowPassFragment(VertexOutput IN ) : SV_TARGET
            {
                UNITY_SETUP_INSTANCE_ID(IN);

                // Pixel transformations performed by graph
                float3 WorldSpacePosition = IN.WorldSpacePosition;
                float3 WorldSpaceNormal = IN.WorldSpaceNormal;
                float3 WorldSpaceTangent = IN.WorldSpaceTangent;
                float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
                float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
                float3x3 tangentSpaceTransform = float3x3(WorldSpaceTangent,WorldSpaceBiTangent,WorldSpaceNormal);
                float4 ScreenPosition = IN.ScreenPosition;
                float4 uv1 = IN.uv1;
                float3 TangentSpaceNormal = mul(WorldSpaceNormal,(float3x3)tangentSpaceTransform).xyz;

                SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

        		// Surface description inputs defined by graph
                surfaceInput.WorldSpaceNormal = WorldSpaceNormal;
                surfaceInput.TangentSpaceNormal = TangentSpaceNormal;
                surfaceInput.WorldSpaceViewDirection = WorldSpaceViewDirection;
                surfaceInput.WorldSpacePosition = WorldSpacePosition;
                surfaceInput.ScreenPosition = ScreenPosition;

                SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

                float3 Albedo = float3(0.5, 0.5, 0.5);
        		float3 Emission = 0;
        		float Alpha = 1;
        		float AlphaClipThreshold = 0;

        		// Surface description remap performed by graph
                Albedo = surf.Albedo;
                Emission = surf.Emission;
                Alpha = surf.Alpha;
                AlphaClipThreshold = surf.AlphaClipThreshold;

         #if _AlphaClip
        		clip(Alpha - AlphaClipThreshold);
        #endif
                return 0;
            }

            ENDHLSL
        }

        Pass
        {
        	Name "DepthOnly"
            Tags{"LightMode" = "DepthOnly"}

            ZWrite On
            ColorMask 0

            // Material options generated by graph
            Cull Back

            HLSLPROGRAM
            // Required to compile gles 2.0 with standard srp library
            #pragma prefer_hlslcc gles
            #pragma exclude_renderers d3d11_9x
            #pragma target 2.0

            //--------------------------------------
            // GPU Instancing
            #pragma multi_compile_instancing

            #pragma vertex vert
            #pragma fragment frag

            // Defines generated by graph
            #define REQUIRE_DEPTH_TEXTURE

            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl"
            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"

            CBUFFER_START(UnityPerMaterial)
            float4 Color_BF3303A0;
            float Vector1_E567A086;
            float Vector1_F2B54871;
            float Vector1_221A0FD9;
            float Vector1_3E734ED8;
            float Vector1_30FC0A4B;
            float Vector1_8FDC4159;
            float4 Color_5856042A;
            float Vector1_33B63372;
            float Vector1_252B0398;
            float Vector1_1B7394EE;
            float Vector1_C3288503;
            float Vector1_4A68B0E6;
            float Vector1_917CCD13;
            CBUFFER_END


            struct VertexDescriptionInputs
            {
                float3 WorldSpaceNormal;
                float3 ObjectSpacePosition;
                float3 WorldSpacePosition;
            };

            struct SurfaceDescriptionInputs
            {
                float3 WorldSpaceNormal;
                float3 TangentSpaceNormal;
                float3 WorldSpaceViewDirection;
                float3 WorldSpacePosition;
                float4 ScreenPosition;
            };


            void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
            {
                RGBA = float4(R, G, B, A);
                RGB = float3(R, G, B);
                RG = float2(R, G);
            }

            void Unity_Multiply_float (float2 A, float2 B, out float2 Out)
            {
                Out = A * B;
            }

            void Unity_Multiply_float (float A, float B, out float Out)
            {
                Out = A * B;
            }

            void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
            {
                Out = UV * Tiling + Offset;
            }


        float2 unity_gradientNoise_dir(float2 p)
        {
            // Permutation and hashing used in webgl-nosie goo.gl/pX7HtC
            p = p % 289;
            float x = (34 * p.x + 1) * p.x % 289 + p.y;
            x = (34 * x + 1) * x % 289;
            x = frac(x / 41) * 2 - 1;
            return normalize(float2(x - floor(x + 0.5), abs(x) - 0.5));
        }


        float unity_gradientNoise(float2 p)
        {
            float2 ip = floor(p);
            float2 fp = frac(p);
            float d00 = dot(unity_gradientNoise_dir(ip), fp);
            float d01 = dot(unity_gradientNoise_dir(ip + float2(0, 1)), fp - float2(0, 1));
            float d10 = dot(unity_gradientNoise_dir(ip + float2(1, 0)), fp - float2(1, 0));
            float d11 = dot(unity_gradientNoise_dir(ip + float2(1, 1)), fp - float2(1, 1));
            fp = fp * fp * fp * (fp * (fp * 6 - 15) + 10);
            return lerp(lerp(d00, d01, fp.y), lerp(d10, d11, fp.y), fp.x);
        }

            void Unity_GradientNoise_float(float2 UV, float Scale, out float Out)
            { Out = unity_gradientNoise(UV * Scale) + 0.5; }

            void Unity_Multiply_float (float3 A, float3 B, out float3 Out)
            {
                Out = A * B;
            }

            void Unity_Add_float3(float3 A, float3 B, out float3 Out)
            {
                Out = A + B;
            }


        inline float2 unity_voronoi_noise_randomVector (float2 UV, float offset)
        {
            float2x2 m = float2x2(15.27, 47.63, 99.41, 89.98);
            UV = frac(sin(mul(UV, m)) * 46839.32);
            return float2(sin(UV.y*+offset)*0.5+0.5, cos(UV.x*offset)*0.5+0.5);
        }

            void Unity_Voronoi_float(float2 UV, float AngleOffset, float CellDensity, out float Out, out float Cells)
            {
                float2 g = floor(UV * CellDensity);
                float2 f = frac(UV * CellDensity);
                float t = 8.0;
                float3 res = float3(8.0, 0.0, 0.0);

                for(int y=-1; y<=1; y++)
                {
                    for(int x=-1; x<=1; x++)
                    {
                        float2 lattice = float2(x,y);
                        float2 offset = unity_voronoi_noise_randomVector(lattice + g, AngleOffset);
                        float d = distance(lattice + offset, f);

                        if(d < res.x)
                        {

                            res = float3(d, offset.x, offset.y);
                            Out = res.x;
                            Cells = res.y;

                        }
                    }

                }

            }

            void Unity_Power_float(float A, float B, out float Out)
            {
                Out = pow(A, B);
            }

            void Unity_Multiply_float (float4 A, float4 B, out float4 Out)
            {
                Out = A * B;
            }

            void Unity_Add_float4(float4 A, float4 B, out float4 Out)
            {
                Out = A + B;
            }

            void Unity_FresnelEffect_float(float3 Normal, float3 ViewDir, float Power, out float Out)
            {
                Out = pow((1.0 - saturate(dot(normalize(Normal), normalize(ViewDir)))), Power);
            }

            void Unity_Lerp_float4(float4 A, float4 B, float4 T, out float4 Out)
            {
                Out = lerp(A, B, T);
            }

            void Unity_Subtract_float3(float3 A, float3 B, out float3 Out)
            {
                Out = A - B;
            }

            void Unity_DotProduct_float3(float3 A, float3 B, out float Out)
            {
                Out = dot(A, B);
            }

            void Unity_Remap_float(float In, float2 InMinMax, float2 OutMinMax, out float Out)
            {
                Out = OutMinMax.x + (In - InMinMax.x) * (OutMinMax.y - OutMinMax.x) / (InMinMax.y - InMinMax.x);
            }

            void Unity_Add_float(float A, float B, out float Out)
            {
                Out = A + B;
            }

            void Unity_SceneDepth_Linear01_float(float4 UV, out float Out)
            {
                Out = Linear01Depth(SHADERGRAPH_SAMPLE_SCENE_DEPTH(UV.xy), _ZBufferParams);
            }

            void Unity_Smoothstep_float(float Edge1, float Edge2, float In, out float Out)
            {
                Out = smoothstep(Edge1, Edge2, In);
            }

            void Unity_Clamp_float(float In, float Min, float Max, out float Out)
            {
                Out = clamp(In, Min, Max);
            }

            void Unity_OneMinus_float(float In, out float Out)
            {
                Out = 1 - In;
            }

            struct VertexDescription
            {
                float3 Position;
            };

            VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
            {
                VertexDescription description = (VertexDescription)0;
                float _Split_49E7322C_R = IN.WorldSpacePosition[0];
                float _Split_49E7322C_G = IN.WorldSpacePosition[1];
                float _Split_49E7322C_B = IN.WorldSpacePosition[2];
                float _Split_49E7322C_A = 0;
                float4 _Combine_690F97BF_RGBA;
                float3 _Combine_690F97BF_RGB;
                float2 _Combine_690F97BF_RG;
                Unity_Combine_float(_Split_49E7322C_R, _Split_49E7322C_B, 0, 0, _Combine_690F97BF_RGBA, _Combine_690F97BF_RGB, _Combine_690F97BF_RG);
                float _Property_27AA5723_Out = Vector1_221A0FD9;
                float2 _Multiply_9915511D_Out;
                Unity_Multiply_float(_Combine_690F97BF_RG, (_Property_27AA5723_Out.xx), _Multiply_9915511D_Out);

                float _Property_5062A5B0_Out = Vector1_33B63372;
                float _Multiply_8B6F13FF_Out;
                Unity_Multiply_float(_Time.y, _Property_5062A5B0_Out, _Multiply_8B6F13FF_Out);

                float2 _TilingAndOffset_C1E9B602_Out;
                Unity_TilingAndOffset_float(_Multiply_9915511D_Out, float2 (1,1), (_Multiply_8B6F13FF_Out.xx), _TilingAndOffset_C1E9B602_Out);
                float _Property_1713DFB6_Out = Vector1_252B0398;
                float _GradientNoise_7C6CFF22_Out;
                Unity_GradientNoise_float(_TilingAndOffset_C1E9B602_Out, _Property_1713DFB6_Out, _GradientNoise_7C6CFF22_Out);
                float3 _Multiply_324A9939_Out;
                Unity_Multiply_float(IN.WorldSpaceNormal, (_GradientNoise_7C6CFF22_Out.xxx), _Multiply_324A9939_Out);

                float3 _Add_84DFD690_Out;
                Unity_Add_float3(_Multiply_324A9939_Out, IN.ObjectSpacePosition, _Add_84DFD690_Out);
                description.Position = _Add_84DFD690_Out;
                return description;
            }

            struct SurfaceDescription
            {
                float3 Albedo;
                float3 Emission;
                float Alpha;
                float AlphaClipThreshold;
            };

            SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
            {
                SurfaceDescription surface = (SurfaceDescription)0;
                float4 _Property_23FE3CE_Out = Color_BF3303A0;
                float _Split_B9847336_R = IN.WorldSpacePosition[0];
                float _Split_B9847336_G = IN.WorldSpacePosition[1];
                float _Split_B9847336_B = IN.WorldSpacePosition[2];
                float _Split_B9847336_A = 0;
                float4 _Combine_EE24E6F2_RGBA;
                float3 _Combine_EE24E6F2_RGB;
                float2 _Combine_EE24E6F2_RG;
                Unity_Combine_float(_Split_B9847336_R, _Split_B9847336_B, 0, 0, _Combine_EE24E6F2_RGBA, _Combine_EE24E6F2_RGB, _Combine_EE24E6F2_RG);
                float _Property_EA233F6C_Out = Vector1_221A0FD9;
                float2 _Multiply_5FBCC94C_Out;
                Unity_Multiply_float(_Combine_EE24E6F2_RG, (_Property_EA233F6C_Out.xx), _Multiply_5FBCC94C_Out);

                float _Property_E794697D_Out = Vector1_3E734ED8;
                float _Multiply_F27D3501_Out;
                Unity_Multiply_float(_Time.y, _Property_E794697D_Out, _Multiply_F27D3501_Out);

                float _Property_DF2E142D_Out = Vector1_30FC0A4B;
                float _Voronoi_EDF64014_Out;
                float _Voronoi_EDF64014_Cells;
                Unity_Voronoi_float(_Multiply_5FBCC94C_Out, _Multiply_F27D3501_Out, _Property_DF2E142D_Out, _Voronoi_EDF64014_Out, _Voronoi_EDF64014_Cells);
                float _Property_F9D7714D_Out = Vector1_8FDC4159;
                float _Power_B15F028A_Out;
                Unity_Power_float(_Voronoi_EDF64014_Out, _Property_F9D7714D_Out, _Power_B15F028A_Out);
                float4 _Property_7F4EBE75_Out = Color_5856042A;
                float4 _Multiply_73F5CD9F_Out;
                Unity_Multiply_float((_Power_B15F028A_Out.xxxx), _Property_7F4EBE75_Out, _Multiply_73F5CD9F_Out);

                float4 _Add_CA03B711_Out;
                Unity_Add_float4(_Property_23FE3CE_Out, _Multiply_73F5CD9F_Out, _Add_CA03B711_Out);
                float4 Color_99AF311E = IsGammaSpace() ? float4(0.3160377, 0.8424633, 1, 0) : float4(SRGBToLinear(float3(0.3160377, 0.8424633, 1)), 0);
                float4 Color_10D69FE0 = IsGammaSpace() ? float4(0, 0.229, 0.1605632, 0) : float4(SRGBToLinear(float3(0, 0.229, 0.1605632)), 0);
                float _FresnelEffect_50DAADA4_Out;
                Unity_FresnelEffect_float(IN.WorldSpaceNormal, IN.WorldSpaceViewDirection, 1, _FresnelEffect_50DAADA4_Out);
                float4 _Lerp_E847765E_Out;
                Unity_Lerp_float4(Color_99AF311E, Color_10D69FE0, (_FresnelEffect_50DAADA4_Out.xxxx), _Lerp_E847765E_Out);
                float4 _Add_D22EED0_Out;
                Unity_Add_float4(_Add_CA03B711_Out, _Lerp_E847765E_Out, _Add_D22EED0_Out);
                float4 _Add_26EF4CB1_Out;
                Unity_Add_float4(_Add_D22EED0_Out, float4(0, 0, 0, 0), _Add_26EF4CB1_Out);
                float3 _Subtract_1A6292B4_Out;
                Unity_Subtract_float3(IN.WorldSpacePosition, _WorldSpaceCameraPos, _Subtract_1A6292B4_Out);
                float _DotProduct_FCEA7241_Out;
                Unity_DotProduct_float3(-1 * mul(UNITY_MATRIX_M, transpose(mul(UNITY_MATRIX_I_M, UNITY_MATRIX_I_V)) [2].xyz), _Subtract_1A6292B4_Out, _DotProduct_FCEA7241_Out);
                float2 _Vector2_66B2C374_Out = float2(0,_ProjectionParams.z);
                float _Remap_DE2C36AE_Out;
                Unity_Remap_float(_DotProduct_FCEA7241_Out, _Vector2_66B2C374_Out, float2 (0,1), _Remap_DE2C36AE_Out);
                float _Property_514FC065_Out = Vector1_1B7394EE;
                float _Add_569553BC_Out;
                Unity_Add_float(_DotProduct_FCEA7241_Out, _Property_514FC065_Out, _Add_569553BC_Out);
                float _Remap_711563B3_Out;
                Unity_Remap_float(_Add_569553BC_Out, _Vector2_66B2C374_Out, float2 (0,1), _Remap_711563B3_Out);
                float _SceneDepth_F365D371_Out;
                Unity_SceneDepth_Linear01_float(float4(IN.ScreenPosition.xy / IN.ScreenPosition.w, 0, 0), _SceneDepth_F365D371_Out);
                float _Smoothstep_84E11D33_Out;
                Unity_Smoothstep_float(_Remap_DE2C36AE_Out, _Remap_711563B3_Out, _SceneDepth_F365D371_Out, _Smoothstep_84E11D33_Out);
                float _Split_7D04ED44_R = IN.WorldSpacePosition[0];
                float _Split_7D04ED44_G = IN.WorldSpacePosition[1];
                float _Split_7D04ED44_B = IN.WorldSpacePosition[2];
                float _Split_7D04ED44_A = 0;
                float4 _Combine_CA14ABE5_RGBA;
                float3 _Combine_CA14ABE5_RGB;
                float2 _Combine_CA14ABE5_RG;
                Unity_Combine_float(_Split_7D04ED44_R, _Split_7D04ED44_B, 0, 0, _Combine_CA14ABE5_RGBA, _Combine_CA14ABE5_RGB, _Combine_CA14ABE5_RG);
                float _Property_459A4526_Out = Vector1_221A0FD9;
                float2 _Multiply_49F38EDE_Out;
                Unity_Multiply_float(_Combine_CA14ABE5_RG, (_Property_459A4526_Out.xx), _Multiply_49F38EDE_Out);

                float _Property_2AB2E5A3_Out = Vector1_917CCD13;
                float _Multiply_8E4C8E2_Out;
                Unity_Multiply_float(_Time.y, _Property_2AB2E5A3_Out, _Multiply_8E4C8E2_Out);

                float2 _TilingAndOffset_2A152B1_Out;
                Unity_TilingAndOffset_float(_Multiply_49F38EDE_Out, float2 (1,1), (_Multiply_8E4C8E2_Out.xx), _TilingAndOffset_2A152B1_Out);
                float _Property_86A70B0B_Out = Vector1_4A68B0E6;
                float _GradientNoise_A48547B4_Out;
                Unity_GradientNoise_float(_TilingAndOffset_2A152B1_Out, _Property_86A70B0B_Out, _GradientNoise_A48547B4_Out);
                float _Property_C544BFEC_Out = Vector1_C3288503;
                float _Clamp_1FFEF810_Out;
                Unity_Clamp_float(_GradientNoise_A48547B4_Out, _Property_C544BFEC_Out, 1, _Clamp_1FFEF810_Out);
                float _Add_BA7C5D1D_Out;
                Unity_Add_float(_Smoothstep_84E11D33_Out, _Clamp_1FFEF810_Out, _Add_BA7C5D1D_Out);
                float _Clamp_BCB4F689_Out;
                Unity_Clamp_float(_Add_BA7C5D1D_Out, 0, 1, _Clamp_BCB4F689_Out);
                float _OneMinus_9D425443_Out;
                Unity_OneMinus_float(_Clamp_BCB4F689_Out, _OneMinus_9D425443_Out);
                float _Property_DAB033DB_Out = Vector1_F2B54871;
                surface.Albedo = (_Add_26EF4CB1_Out.xyz);
                surface.Emission = (_OneMinus_9D425443_Out.xxx);
                surface.Alpha = _Property_DAB033DB_Out;
                surface.AlphaClipThreshold = 0.5;
                return surface;
            }

            struct GraphVertexInput
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                float4 texcoord1 : TEXCOORD1;
                UNITY_VERTEX_INPUT_INSTANCE_ID
            };


        	struct VertexOutput
        	{
        	    float2 uv           : TEXCOORD0;
        	    float4 clipPos      : SV_POSITION;
                // Interpolators defined by graph
                float3 WorldSpacePosition : TEXCOORD3;
                float3 WorldSpaceNormal : TEXCOORD4;
                float3 WorldSpaceTangent : TEXCOORD5;
                float3 WorldSpaceBiTangent : TEXCOORD6;
                float3 WorldSpaceViewDirection : TEXCOORD7;
                float4 ScreenPosition : TEXCOORD8;
                half4 uv1 : TEXCOORD9;

                UNITY_VERTEX_INPUT_INSTANCE_ID
                UNITY_VERTEX_OUTPUT_STEREO
        	};

            VertexOutput vert(GraphVertexInput v)
            {
                VertexOutput o = (VertexOutput)0;
        	    UNITY_SETUP_INSTANCE_ID(v);
                UNITY_TRANSFER_INSTANCE_ID(v, o);
                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

        	    // Vertex transformations performed by graph
                float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
                float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
                float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
                float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
                float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
                float4 ScreenPosition = ComputeScreenPos(mul(GetWorldToHClipMatrix(), mul(GetObjectToWorldMatrix(), v.vertex)), _ProjectionParams.x);
                float4 uv1 = v.texcoord1;
                float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;

        		VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

                // Vertex description inputs defined by graph
                vdi.WorldSpaceNormal = WorldSpaceNormal;
                vdi.ObjectSpacePosition = ObjectSpacePosition;
                vdi.WorldSpacePosition = WorldSpacePosition;

        	    VertexDescription vd = PopulateVertexData(vdi);
                v.vertex.xyz = vd.Position;

                ScreenPosition = ComputeScreenPos(mul(GetWorldToHClipMatrix(), mul(GetObjectToWorldMatrix(), v.vertex)), _ProjectionParams.x);

        	    // Vertex shader outputs defined by graph
                o.WorldSpacePosition = WorldSpacePosition;
                o.WorldSpaceNormal = WorldSpaceNormal;
                o.WorldSpaceTangent = WorldSpaceTangent;
                o.WorldSpaceBiTangent = WorldSpaceBiTangent;
                o.WorldSpaceViewDirection = WorldSpaceViewDirection;
                o.ScreenPosition = ScreenPosition;
                o.uv1 = uv1;

        	    o.clipPos = TransformObjectToHClip(v.vertex.xyz);
        	    return o;
            }

            half4 frag(VertexOutput IN ) : SV_TARGET
            {
                UNITY_SETUP_INSTANCE_ID(IN);
        		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);

                // Pixel transformations performed by graph
                float3 WorldSpacePosition = IN.WorldSpacePosition;
                float3 WorldSpaceNormal = IN.WorldSpaceNormal;
                float3 WorldSpaceTangent = IN.WorldSpaceTangent;
                float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
                float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
                float3x3 tangentSpaceTransform = float3x3(WorldSpaceTangent,WorldSpaceBiTangent,WorldSpaceNormal);
                float4 ScreenPosition = IN.ScreenPosition;
                float4 uv1 = IN.uv1;
                float3 TangentSpaceNormal = mul(WorldSpaceNormal,(float3x3)tangentSpaceTransform).xyz;

                SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

        		// Surface description inputs defined by graph
                surfaceInput.WorldSpaceNormal = WorldSpaceNormal;
                surfaceInput.TangentSpaceNormal = TangentSpaceNormal;
                surfaceInput.WorldSpaceViewDirection = WorldSpaceViewDirection;
                surfaceInput.WorldSpacePosition = WorldSpacePosition;
                surfaceInput.ScreenPosition = ScreenPosition;

                SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

                float3 Albedo = float3(0.5, 0.5, 0.5);
        		float3 Emission = 0;
        		float Alpha = 1;
        		float AlphaClipThreshold = 0;

        		// Surface description remap performed by graph
                Albedo = surf.Albedo;
                Emission = surf.Emission;
                Alpha = surf.Alpha;
                AlphaClipThreshold = surf.AlphaClipThreshold;

         #if _AlphaClip
        		clip(Alpha - AlphaClipThreshold);
        #endif
                return 0;
            }
            ENDHLSL
        }

        // This pass it not used during regular rendering, only for lightmap baking.
        Pass
        {
        	Name "Meta"
            Tags{"LightMode" = "Meta"}

            Cull Off

            HLSLPROGRAM
            // Required to compile gles 2.0 with standard srp library
            #pragma prefer_hlslcc gles
            #pragma exclude_renderers d3d11_9x
            #pragma target 2.0

            #pragma vertex vert
            #pragma fragment frag

            float4 _MainTex_ST;

            // Defines generated by graph
            #define REQUIRE_DEPTH_TEXTURE

            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/MetaInput.hlsl"
            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"

            #pragma shader_feature _ _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A

                CBUFFER_START(UnityPerMaterial)
            float4 Color_BF3303A0;
            float Vector1_E567A086;
            float Vector1_F2B54871;
            float Vector1_221A0FD9;
            float Vector1_3E734ED8;
            float Vector1_30FC0A4B;
            float Vector1_8FDC4159;
            float4 Color_5856042A;
            float Vector1_33B63372;
            float Vector1_252B0398;
            float Vector1_1B7394EE;
            float Vector1_C3288503;
            float Vector1_4A68B0E6;
            float Vector1_917CCD13;
            CBUFFER_END


            struct VertexDescriptionInputs
            {
                float3 WorldSpaceNormal;
                float3 ObjectSpacePosition;
                float3 WorldSpacePosition;
            };

            struct SurfaceDescriptionInputs
            {
                float3 WorldSpaceNormal;
                float3 TangentSpaceNormal;
                float3 WorldSpaceViewDirection;
                float3 WorldSpacePosition;
                float4 ScreenPosition;
            };


            void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
            {
                RGBA = float4(R, G, B, A);
                RGB = float3(R, G, B);
                RG = float2(R, G);
            }

            void Unity_Multiply_float (float2 A, float2 B, out float2 Out)
            {
                Out = A * B;
            }

            void Unity_Multiply_float (float A, float B, out float Out)
            {
                Out = A * B;
            }

            void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
            {
                Out = UV * Tiling + Offset;
            }


        float2 unity_gradientNoise_dir(float2 p)
        {
            // Permutation and hashing used in webgl-nosie goo.gl/pX7HtC
            p = p % 289;
            float x = (34 * p.x + 1) * p.x % 289 + p.y;
            x = (34 * x + 1) * x % 289;
            x = frac(x / 41) * 2 - 1;
            return normalize(float2(x - floor(x + 0.5), abs(x) - 0.5));
        }


        float unity_gradientNoise(float2 p)
        {
            float2 ip = floor(p);
            float2 fp = frac(p);
            float d00 = dot(unity_gradientNoise_dir(ip), fp);
            float d01 = dot(unity_gradientNoise_dir(ip + float2(0, 1)), fp - float2(0, 1));
            float d10 = dot(unity_gradientNoise_dir(ip + float2(1, 0)), fp - float2(1, 0));
            float d11 = dot(unity_gradientNoise_dir(ip + float2(1, 1)), fp - float2(1, 1));
            fp = fp * fp * fp * (fp * (fp * 6 - 15) + 10);
            return lerp(lerp(d00, d01, fp.y), lerp(d10, d11, fp.y), fp.x);
        }

            void Unity_GradientNoise_float(float2 UV, float Scale, out float Out)
            { Out = unity_gradientNoise(UV * Scale) + 0.5; }

            void Unity_Multiply_float (float3 A, float3 B, out float3 Out)
            {
                Out = A * B;
            }

            void Unity_Add_float3(float3 A, float3 B, out float3 Out)
            {
                Out = A + B;
            }


        inline float2 unity_voronoi_noise_randomVector (float2 UV, float offset)
        {
            float2x2 m = float2x2(15.27, 47.63, 99.41, 89.98);
            UV = frac(sin(mul(UV, m)) * 46839.32);
            return float2(sin(UV.y*+offset)*0.5+0.5, cos(UV.x*offset)*0.5+0.5);
        }

            void Unity_Voronoi_float(float2 UV, float AngleOffset, float CellDensity, out float Out, out float Cells)
            {
                float2 g = floor(UV * CellDensity);
                float2 f = frac(UV * CellDensity);
                float t = 8.0;
                float3 res = float3(8.0, 0.0, 0.0);

                for(int y=-1; y<=1; y++)
                {
                    for(int x=-1; x<=1; x++)
                    {
                        float2 lattice = float2(x,y);
                        float2 offset = unity_voronoi_noise_randomVector(lattice + g, AngleOffset);
                        float d = distance(lattice + offset, f);

                        if(d < res.x)
                        {

                            res = float3(d, offset.x, offset.y);
                            Out = res.x;
                            Cells = res.y;

                        }
                    }

                }

            }

            void Unity_Power_float(float A, float B, out float Out)
            {
                Out = pow(A, B);
            }

            void Unity_Multiply_float (float4 A, float4 B, out float4 Out)
            {
                Out = A * B;
            }

            void Unity_Add_float4(float4 A, float4 B, out float4 Out)
            {
                Out = A + B;
            }

            void Unity_FresnelEffect_float(float3 Normal, float3 ViewDir, float Power, out float Out)
            {
                Out = pow((1.0 - saturate(dot(normalize(Normal), normalize(ViewDir)))), Power);
            }

            void Unity_Lerp_float4(float4 A, float4 B, float4 T, out float4 Out)
            {
                Out = lerp(A, B, T);
            }

            void Unity_Subtract_float3(float3 A, float3 B, out float3 Out)
            {
                Out = A - B;
            }

            void Unity_DotProduct_float3(float3 A, float3 B, out float Out)
            {
                Out = dot(A, B);
            }

            void Unity_Remap_float(float In, float2 InMinMax, float2 OutMinMax, out float Out)
            {
                Out = OutMinMax.x + (In - InMinMax.x) * (OutMinMax.y - OutMinMax.x) / (InMinMax.y - InMinMax.x);
            }

            void Unity_Add_float(float A, float B, out float Out)
            {
                Out = A + B;
            }

            void Unity_SceneDepth_Linear01_float(float4 UV, out float Out)
            {
                Out = Linear01Depth(SHADERGRAPH_SAMPLE_SCENE_DEPTH(UV.xy), _ZBufferParams);
            }

            void Unity_Smoothstep_float(float Edge1, float Edge2, float In, out float Out)
            {
                Out = smoothstep(Edge1, Edge2, In);
            }

            void Unity_Clamp_float(float In, float Min, float Max, out float Out)
            {
                Out = clamp(In, Min, Max);
            }

            void Unity_OneMinus_float(float In, out float Out)
            {
                Out = 1 - In;
            }

            struct VertexDescription
            {
                float3 Position;
            };

            VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
            {
                VertexDescription description = (VertexDescription)0;
                float _Split_49E7322C_R = IN.WorldSpacePosition[0];
                float _Split_49E7322C_G = IN.WorldSpacePosition[1];
                float _Split_49E7322C_B = IN.WorldSpacePosition[2];
                float _Split_49E7322C_A = 0;
                float4 _Combine_690F97BF_RGBA;
                float3 _Combine_690F97BF_RGB;
                float2 _Combine_690F97BF_RG;
                Unity_Combine_float(_Split_49E7322C_R, _Split_49E7322C_B, 0, 0, _Combine_690F97BF_RGBA, _Combine_690F97BF_RGB, _Combine_690F97BF_RG);
                float _Property_27AA5723_Out = Vector1_221A0FD9;
                float2 _Multiply_9915511D_Out;
                Unity_Multiply_float(_Combine_690F97BF_RG, (_Property_27AA5723_Out.xx), _Multiply_9915511D_Out);

                float _Property_5062A5B0_Out = Vector1_33B63372;
                float _Multiply_8B6F13FF_Out;
                Unity_Multiply_float(_Time.y, _Property_5062A5B0_Out, _Multiply_8B6F13FF_Out);

                float2 _TilingAndOffset_C1E9B602_Out;
                Unity_TilingAndOffset_float(_Multiply_9915511D_Out, float2 (1,1), (_Multiply_8B6F13FF_Out.xx), _TilingAndOffset_C1E9B602_Out);
                float _Property_1713DFB6_Out = Vector1_252B0398;
                float _GradientNoise_7C6CFF22_Out;
                Unity_GradientNoise_float(_TilingAndOffset_C1E9B602_Out, _Property_1713DFB6_Out, _GradientNoise_7C6CFF22_Out);
                float3 _Multiply_324A9939_Out;
                Unity_Multiply_float(IN.WorldSpaceNormal, (_GradientNoise_7C6CFF22_Out.xxx), _Multiply_324A9939_Out);

                float3 _Add_84DFD690_Out;
                Unity_Add_float3(_Multiply_324A9939_Out, IN.ObjectSpacePosition, _Add_84DFD690_Out);
                description.Position = _Add_84DFD690_Out;
                return description;
            }

            struct SurfaceDescription
            {
                float3 Albedo;
                float3 Emission;
                float Alpha;
                float AlphaClipThreshold;
            };

            SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
            {
                SurfaceDescription surface = (SurfaceDescription)0;
                float4 _Property_23FE3CE_Out = Color_BF3303A0;
                float _Split_B9847336_R = IN.WorldSpacePosition[0];
                float _Split_B9847336_G = IN.WorldSpacePosition[1];
                float _Split_B9847336_B = IN.WorldSpacePosition[2];
                float _Split_B9847336_A = 0;
                float4 _Combine_EE24E6F2_RGBA;
                float3 _Combine_EE24E6F2_RGB;
                float2 _Combine_EE24E6F2_RG;
                Unity_Combine_float(_Split_B9847336_R, _Split_B9847336_B, 0, 0, _Combine_EE24E6F2_RGBA, _Combine_EE24E6F2_RGB, _Combine_EE24E6F2_RG);
                float _Property_EA233F6C_Out = Vector1_221A0FD9;
                float2 _Multiply_5FBCC94C_Out;
                Unity_Multiply_float(_Combine_EE24E6F2_RG, (_Property_EA233F6C_Out.xx), _Multiply_5FBCC94C_Out);

                float _Property_E794697D_Out = Vector1_3E734ED8;
                float _Multiply_F27D3501_Out;
                Unity_Multiply_float(_Time.y, _Property_E794697D_Out, _Multiply_F27D3501_Out);

                float _Property_DF2E142D_Out = Vector1_30FC0A4B;
                float _Voronoi_EDF64014_Out;
                float _Voronoi_EDF64014_Cells;
                Unity_Voronoi_float(_Multiply_5FBCC94C_Out, _Multiply_F27D3501_Out, _Property_DF2E142D_Out, _Voronoi_EDF64014_Out, _Voronoi_EDF64014_Cells);
                float _Property_F9D7714D_Out = Vector1_8FDC4159;
                float _Power_B15F028A_Out;
                Unity_Power_float(_Voronoi_EDF64014_Out, _Property_F9D7714D_Out, _Power_B15F028A_Out);
                float4 _Property_7F4EBE75_Out = Color_5856042A;
                float4 _Multiply_73F5CD9F_Out;
                Unity_Multiply_float((_Power_B15F028A_Out.xxxx), _Property_7F4EBE75_Out, _Multiply_73F5CD9F_Out);

                float4 _Add_CA03B711_Out;
                Unity_Add_float4(_Property_23FE3CE_Out, _Multiply_73F5CD9F_Out, _Add_CA03B711_Out);
                float4 Color_99AF311E = IsGammaSpace() ? float4(0.3160377, 0.8424633, 1, 0) : float4(SRGBToLinear(float3(0.3160377, 0.8424633, 1)), 0);
                float4 Color_10D69FE0 = IsGammaSpace() ? float4(0, 0.229, 0.1605632, 0) : float4(SRGBToLinear(float3(0, 0.229, 0.1605632)), 0);
                float _FresnelEffect_50DAADA4_Out;
                Unity_FresnelEffect_float(IN.WorldSpaceNormal, IN.WorldSpaceViewDirection, 1, _FresnelEffect_50DAADA4_Out);
                float4 _Lerp_E847765E_Out;
                Unity_Lerp_float4(Color_99AF311E, Color_10D69FE0, (_FresnelEffect_50DAADA4_Out.xxxx), _Lerp_E847765E_Out);
                float4 _Add_D22EED0_Out;
                Unity_Add_float4(_Add_CA03B711_Out, _Lerp_E847765E_Out, _Add_D22EED0_Out);
                float4 _Add_26EF4CB1_Out;
                Unity_Add_float4(_Add_D22EED0_Out, float4(0, 0, 0, 0), _Add_26EF4CB1_Out);
                float3 _Subtract_1A6292B4_Out;
                Unity_Subtract_float3(IN.WorldSpacePosition, _WorldSpaceCameraPos, _Subtract_1A6292B4_Out);
                float _DotProduct_FCEA7241_Out;
                Unity_DotProduct_float3(-1 * mul(UNITY_MATRIX_M, transpose(mul(UNITY_MATRIX_I_M, UNITY_MATRIX_I_V)) [2].xyz), _Subtract_1A6292B4_Out, _DotProduct_FCEA7241_Out);
                float2 _Vector2_66B2C374_Out = float2(0,_ProjectionParams.z);
                float _Remap_DE2C36AE_Out;
                Unity_Remap_float(_DotProduct_FCEA7241_Out, _Vector2_66B2C374_Out, float2 (0,1), _Remap_DE2C36AE_Out);
                float _Property_514FC065_Out = Vector1_1B7394EE;
                float _Add_569553BC_Out;
                Unity_Add_float(_DotProduct_FCEA7241_Out, _Property_514FC065_Out, _Add_569553BC_Out);
                float _Remap_711563B3_Out;
                Unity_Remap_float(_Add_569553BC_Out, _Vector2_66B2C374_Out, float2 (0,1), _Remap_711563B3_Out);
                float _SceneDepth_F365D371_Out;
                Unity_SceneDepth_Linear01_float(float4(IN.ScreenPosition.xy / IN.ScreenPosition.w, 0, 0), _SceneDepth_F365D371_Out);
                float _Smoothstep_84E11D33_Out;
                Unity_Smoothstep_float(_Remap_DE2C36AE_Out, _Remap_711563B3_Out, _SceneDepth_F365D371_Out, _Smoothstep_84E11D33_Out);
                float _Split_7D04ED44_R = IN.WorldSpacePosition[0];
                float _Split_7D04ED44_G = IN.WorldSpacePosition[1];
                float _Split_7D04ED44_B = IN.WorldSpacePosition[2];
                float _Split_7D04ED44_A = 0;
                float4 _Combine_CA14ABE5_RGBA;
                float3 _Combine_CA14ABE5_RGB;
                float2 _Combine_CA14ABE5_RG;
                Unity_Combine_float(_Split_7D04ED44_R, _Split_7D04ED44_B, 0, 0, _Combine_CA14ABE5_RGBA, _Combine_CA14ABE5_RGB, _Combine_CA14ABE5_RG);
                float _Property_459A4526_Out = Vector1_221A0FD9;
                float2 _Multiply_49F38EDE_Out;
                Unity_Multiply_float(_Combine_CA14ABE5_RG, (_Property_459A4526_Out.xx), _Multiply_49F38EDE_Out);

                float _Property_2AB2E5A3_Out = Vector1_917CCD13;
                float _Multiply_8E4C8E2_Out;
                Unity_Multiply_float(_Time.y, _Property_2AB2E5A3_Out, _Multiply_8E4C8E2_Out);

                float2 _TilingAndOffset_2A152B1_Out;
                Unity_TilingAndOffset_float(_Multiply_49F38EDE_Out, float2 (1,1), (_Multiply_8E4C8E2_Out.xx), _TilingAndOffset_2A152B1_Out);
                float _Property_86A70B0B_Out = Vector1_4A68B0E6;
                float _GradientNoise_A48547B4_Out;
                Unity_GradientNoise_float(_TilingAndOffset_2A152B1_Out, _Property_86A70B0B_Out, _GradientNoise_A48547B4_Out);
                float _Property_C544BFEC_Out = Vector1_C3288503;
                float _Clamp_1FFEF810_Out;
                Unity_Clamp_float(_GradientNoise_A48547B4_Out, _Property_C544BFEC_Out, 1, _Clamp_1FFEF810_Out);
                float _Add_BA7C5D1D_Out;
                Unity_Add_float(_Smoothstep_84E11D33_Out, _Clamp_1FFEF810_Out, _Add_BA7C5D1D_Out);
                float _Clamp_BCB4F689_Out;
                Unity_Clamp_float(_Add_BA7C5D1D_Out, 0, 1, _Clamp_BCB4F689_Out);
                float _OneMinus_9D425443_Out;
                Unity_OneMinus_float(_Clamp_BCB4F689_Out, _OneMinus_9D425443_Out);
                float _Property_DAB033DB_Out = Vector1_F2B54871;
                surface.Albedo = (_Add_26EF4CB1_Out.xyz);
                surface.Emission = (_OneMinus_9D425443_Out.xxx);
                surface.Alpha = _Property_DAB033DB_Out;
                surface.AlphaClipThreshold = 0.5;
                return surface;
            }

            struct GraphVertexInput
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                float4 texcoord1 : TEXCOORD1;
                UNITY_VERTEX_INPUT_INSTANCE_ID
            };


        	struct VertexOutput
        	{
        	    float2 uv           : TEXCOORD0;
        	    float4 clipPos      : SV_POSITION;
                // Interpolators defined by graph
                float3 WorldSpacePosition : TEXCOORD3;
                float3 WorldSpaceNormal : TEXCOORD4;
                float3 WorldSpaceTangent : TEXCOORD5;
                float3 WorldSpaceBiTangent : TEXCOORD6;
                float3 WorldSpaceViewDirection : TEXCOORD7;
                float4 ScreenPosition : TEXCOORD8;
                half4 uv1 : TEXCOORD9;

                UNITY_VERTEX_INPUT_INSTANCE_ID
                UNITY_VERTEX_OUTPUT_STEREO
        	};

            VertexOutput vert(GraphVertexInput v)
            {
                VertexOutput o = (VertexOutput)0;
        	    UNITY_SETUP_INSTANCE_ID(v);
                UNITY_TRANSFER_INSTANCE_ID(v, o);
                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

        	    // Vertex transformations performed by graph
                float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
                float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
                float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
                float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
                float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
                float4 ScreenPosition = ComputeScreenPos(mul(GetWorldToHClipMatrix(), mul(GetObjectToWorldMatrix(), v.vertex)), _ProjectionParams.x);
                float4 uv1 = v.texcoord1;
                float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;


        	    // Vertex shader outputs defined by graph
                o.WorldSpacePosition = WorldSpacePosition;
                o.WorldSpaceNormal = WorldSpaceNormal;
                o.WorldSpaceTangent = WorldSpaceTangent;
                o.WorldSpaceBiTangent = WorldSpaceBiTangent;
                o.WorldSpaceViewDirection = WorldSpaceViewDirection;
                o.ScreenPosition = ScreenPosition;
                o.uv1 = uv1;

                o.clipPos = MetaVertexPosition(v.vertex, uv1, uv1, unity_LightmapST);
        	    return o;
            }

            half4 frag(VertexOutput IN ) : SV_TARGET
            {
                UNITY_SETUP_INSTANCE_ID(IN);
        		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);

                // Pixel transformations performed by graph
                float3 WorldSpacePosition = IN.WorldSpacePosition;
                float3 WorldSpaceNormal = IN.WorldSpaceNormal;
                float3 WorldSpaceTangent = IN.WorldSpaceTangent;
                float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
                float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
                float3x3 tangentSpaceTransform = float3x3(WorldSpaceTangent,WorldSpaceBiTangent,WorldSpaceNormal);
                float4 ScreenPosition = IN.ScreenPosition;
                float4 uv1 = IN.uv1;
                float3 TangentSpaceNormal = mul(WorldSpaceNormal,(float3x3)tangentSpaceTransform).xyz;

                SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

        		// Surface description inputs defined by graph
                surfaceInput.WorldSpaceNormal = WorldSpaceNormal;
                surfaceInput.TangentSpaceNormal = TangentSpaceNormal;
                surfaceInput.WorldSpaceViewDirection = WorldSpaceViewDirection;
                surfaceInput.WorldSpacePosition = WorldSpacePosition;
                surfaceInput.ScreenPosition = ScreenPosition;

                SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

        		float3 Albedo = float3(0.5, 0.5, 0.5);
        		float3 Emission = 0;
        		float Alpha = 1;
        		float AlphaClipThreshold = 0;

        		// Surface description remap performed by graph
                Albedo = surf.Albedo;
                Emission = surf.Emission;
                Alpha = surf.Alpha;
                AlphaClipThreshold = surf.AlphaClipThreshold;

         #if _AlphaClip
        		clip(Alpha - AlphaClipThreshold);
        #endif

                MetaInput metaInput = (MetaInput)0;
                metaInput.Albedo = Albedo;
                metaInput.Emission = Emission;
                
                return MetaFragment(metaInput);
            }
            ENDHLSL
        }
    }
    CustomEditor "UnityEditor.ShaderGraph.PBRMasterGUI"
    FallBack "Hidden/InternalErrorShader"
}
